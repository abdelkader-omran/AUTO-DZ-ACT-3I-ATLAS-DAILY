#!/usr/bin/env python3
"""
TRIZEL Monitor â€” Daily Snapshot + Historical Backfill (backfill-ready)

Outputs (stable daily filenames):
  data/snapshots/snapshot_YYYY-MM-DD.json
  data/manifests/manifest_YYYY-MM-DD.json

Modes:
  1) Daily (default): no args => run today only
  2) Single day: --day YYYY-MM-DD
  3) Range/backfill: --start-date YYYY-MM-DD [--end-date YYYY-MM-DD]
     - If end_date omitted => end_date = start_date
  4) Overwrite control:
     - default: if files exist => SKIP (range mode) or exit cleanly (single day)
     - --overwrite => replace existing files

This script archives registry-defined "official raw data descriptors" (e.g., URLs/IDs)
as JSON provenance for reproducibility. It does not generate processed images.
"""

import argparse
import hashlib
import json
import os
import sys
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone, date
from pathlib import Path
from typing import Any, Dict, Tuple, Optional


# ----------------------------
# Paths / constants
# ----------------------------
ROOT = Path(__file__).resolve().parents[1]
REGISTRY_FILE = ROOT / "registry" / "sources.json"
DATA_DIR = ROOT / "data"
SNAPSHOT_DIR = DATA_DIR / "snapshots"
MANIFEST_DIR = DATA_DIR / "manifests"

SNAPSHOT_SCHEMA = "auto-dz-act.snapshot.v1"
MANIFEST_SCHEMA = "auto-dz-act.manifest.v1"
SCRIPT_ID = "trizel_monitor.py"
SCRIPT_VERSION = "backfill-ready.v1"


# ----------------------------
# Utilities
# ----------------------------
def utc_now_iso() -> str:
    return datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")


def sha256_bytes(data: bytes) -> str:
    return hashlib.sha256(data).hexdigest()


def parse_yyyy_mm_dd(s: str) -> date:
    try:
        return datetime.strptime(s, "%Y-%m-%d").date()
    except ValueError as e:
        raise ValueError(f"Invalid date '{s}'. Expected YYYY-MM-DD.") from e


def ensure_dirs() -> None:
    SNAPSHOT_DIR.mkdir(parents=True, exist_ok=True)
    MANIFEST_DIR.mkdir(parents=True, exist_ok=True)


def load_registry() -> Dict[str, Any]:
    if not REGISTRY_FILE.exists():
        raise FileNotFoundError(
            f"Registry not found: {REGISTRY_FILE}. Expected a JSON file with 'object' and 'sources'."
        )
    with open(REGISTRY_FILE, "r", encoding="utf-8") as f:
        return json.load(f)


@dataclass(frozen=True)
class RunPlan:
    start: date
    end: date
    overwrite: bool


def build_arg_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog="trizel_monitor.py",
        description="TRIZEL Monitor (daily snapshot or historical backfill).",
    )

    # Canonical flags (match workflow)
    p.add_argument("--start-date", dest="start_date", help="Backfill start date (YYYY-MM-DD).")
    p.add_argument("--end-date", dest="end_date", help="Backfill end date (YYYY-MM-DD).")
    p.add_argument("--day", dest="day", help="Run for a single day (YYYY-MM-DD).")

    # Overwrite behavior
    p.add_argument(
        "--overwrite",
        action="store_true",
        help="Overwrite existing snapshot/manifest files for targeted days.",
    )

    # Backward compatibility (hidden)
    p.add_argument("--start", dest="start_legacy", help=argparse.SUPPRESS)
    p.add_argument("--end", dest="end_legacy", help=argparse.SUPPRESS)

    return p


def resolve_plan(args: argparse.Namespace) -> RunPlan:
    # Priority:
    # 1) --day
    # 2) --start-date/--end-date
    # 3) legacy --start/--end
    # 4) today only

    if args.day:
        d = parse_yyyy_mm_dd(args.day)
        return RunPlan(start=d, end=d, overwrite=bool(args.overwrite))

    start_str = args.start_date or args.start_legacy
    end_str = args.end_date or args.end_legacy

    if start_str:
        start_d = parse_yyyy_mm_dd(start_str)
        end_d = parse_yyyy_mm_dd(end_str) if end_str else start_d
        if end_d < start_d:
            raise ValueError(f"end_date {end_d} is earlier than start_date {start_d}.")
        return RunPlan(start=start_d, end=end_d, overwrite=bool(args.overwrite))

    today = datetime.now(timezone.utc).date()
    return RunPlan(start=today, end=today, overwrite=bool(args.overwrite))


def snapshot_paths_for_day(d: date) -> Tuple[Path, Path]:
    day_str = d.strftime("%Y-%m-%d")
    snap_path = SNAPSHOT_DIR / f"snapshot_{day_str}.json"
    man_path = MANIFEST_DIR / f"manifest_{day_str}.json"
    return snap_path, man_path


def write_snapshot_and_manifest(
    *,
    registry: Dict[str, Any],
    requested_day: date,
    overwrite: bool,
) -> Tuple[Optional[Path], Optional[Path], str]:
    """
    Returns (snapshot_path_or_None, manifest_path_or_None, status)
    status in {"written", "skipped"}.
    """
    ensure_dirs()

    snap_path, man_path = snapshot_paths_for_day(requested_day)

    if (snap_path.exists() or man_path.exists()) and not overwrite:
        return None, None, "skipped"

    retrieved_utc = utc_now_iso()
    requested_day_str = requested_day.strftime("%Y-%m-%d")

    snapshot: Dict[str, Any] = {
        "schema": SNAPSHOT_SCHEMA,
        "object": registry.get("object", "3I/ATLAS"),
        # Keep historical clarity:
        "requested_day_utc": requested_day_str,
        "retrieved_utc": retrieved_utc,
        # Backward compatibility field (some tooling expects this):
        "generated_at_utc": retrieved_utc,
        # Registry-specified official sources / descriptors:
        "sources": registry.get("sources", []),
        # Explicit scope statement:
        "scope": {
            "raw_official_descriptors_only": True,
            "no_processed_images": True,
            "no_scientific_interpretation": True,
        },
        "provenance": {
            "script": SCRIPT_ID,
            "script_version": SCRIPT_VERSION,
            "repo_root": str(ROOT),
        },
    }

    snapshot_bytes = json.dumps(snapshot, ensure_ascii=False, indent=2).encode("utf-8")
    snapshot_hash = sha256_bytes(snapshot_bytes)

    snap_path.write_bytes(snapshot_bytes)

    manifest: Dict[str, Any] = {
        "schema": MANIFEST_SCHEMA,
        "requested_day_utc": requested_day_str,
        "retrieved_utc": retrieved_utc,
        "generated_at_utc": retrieved_utc,
        "snapshot_file": snap_path.name,
        "snapshot_sha256": snapshot_hash,
        "snapshot_bytes": len(snapshot_bytes),
        "integrity": {
            "generated_automatically": True,
            "no_interpretation_applied": True,
            "overwrite": bool(overwrite),
        },
        "environment": {
            "python": sys.version.split()[0],
            "platform": sys.platform,
            "cwd": os.getcwd(),
        },
        "provenance": {
            "script": SCRIPT_ID,
            "script_version": SCRIPT_VERSION,
        },
    }

    manifest_bytes = json.dumps(manifest, ensure_ascii=False, indent=2).encode("utf-8")
    man_path.write_bytes(manifest_bytes)

    return snap_path, man_path, "written"


def main() -> int:
    parser = build_arg_parser()
    args = parser.parse_args()

    try:
        plan = resolve_plan(args)
    except Exception as e:
        print(f"ERROR: {e}", file=sys.stderr)
        return 2

    try:
        registry = load_registry()
    except Exception as e:
        print(f"ERROR: {e}", file=sys.stderr)
        return 1

    total_days = (plan.end - plan.start).days + 1
    print(
        f"TRIZEL Monitor: plan start={plan.start} end={plan.end} days={total_days} overwrite={plan.overwrite}"
    )

    written = 0
    skipped = 0

    d = plan.start
    while d <= plan.end:
        snap_path, man_path, status = write_snapshot_and_manifest(
            registry=registry,
            requested_day=d,
            overwrite=plan.overwrite,
        )

        if status == "skipped":
            skipped += 1
            print(f"[SKIP] {d} (files already exist). Use --overwrite to replace.")
        else:
            written += 1
            print(f"[OK]   {d} -> {snap_path} ; {man_path}")

        d += timedelta(days=1)

    print(f"Done. written={written} skipped={skipped} total={total_days}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())